# 分组查询

## 创建分组(GROUP BY)

> 分组查询

```sql
# 按科目分组，统计每个科目的平均成绩
SELECT stu_subject, AVG(score) FROM student_score GROUP BY stu_subject;
```

> 带 WHERE 的分组查询（先过滤再分组）

```sql
# 按科目分组，统计每个科目中大于等于60分的平均成绩
SELECT stu_subject, AVG(score) FROM student_score WHERE score >= 60 GROUP BY stu_subject;
```

> 作用于分组的过滤条件（HAVING，先分组再过滤）

```sql
# 按科目分组，统计每个科目的平均成绩中大于73的分组
SELECT stu_subject, AVG(score) FROM student_score GROUP BY stu_subject HAVING AVG(score) > 73;
```

> 分组排序

```sql
# 按科目分组，统计每个科目的平均成绩，按递减排序
SELECT stu_subject, AVG(score) AS avg_score FROM student_score GROUP BY stu_subject ORDER BY avg_score DESC;
```

> 嵌套分组

```sql
# 按学院分组，再按专业分组，统计每个专业组中有多少条数据
SELECT department, major, COUNT(*) FROM student_info GROUP BY department, major;
```

# 子查询

## 标量子查询

```sql
# 先在信息表中查询杜琦燕的学号，然后再用学号去成绩表中查询成绩
SELECT * FROM student_score WHERE stu_number = (SELECT stu_number FROM student_info WHERE name = '杜琦燕');

# 查询专业是计算机科学与工程所有学生的成绩
SELECT * FROM student_score WHERE stu_number IN (SELECT stu_number FROM student_info WHERE major = '计算机科学与工程');
```

## EXISTS 和 NOT EXISTS 子查询

```sql
# 若子查询是空集则直接退出查询
SELECT * FROM student_score WHERE EXISTS (SELECT * FROM student_info WHERE stu_number = 20180108);
```

## 对同一个表的子查询

> <span style="color:red">错误查询，聚集函数不能放到 WHERE 子句中。</span>

```sql
# 错误示例
SELECT * FROM student_score WHERE subject = '母猪的产后护理' AND score > AVG(score);
```

> 通过对同一个表进行子查询解决。

```sql
SELECT * FROM student_score WHERE subject = '母猪的产后护理' AND score > (SELECT AVG(score) FROM student_score WHERE subject = '母猪的产后护理');
```
